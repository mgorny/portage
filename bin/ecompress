#!/bin/bash
# Copyright 1999-2018 Gentoo Foundation
# Distributed under the terms of the GNU General Public License v2

source "${PORTAGE_BIN_PATH}"/isolated-functions.sh || exit 1

if [[ -z $1 ]] ; then
	__helpers_die "${0##*/}: at least one argument needed"
	exit 1
fi

if ! ___eapi_has_prefix_variables; then
	ED=${D} EPREFIX=
fi

while [[ $# -gt 0 ]] ; do
	case $1 in
	--ignore)
		shift

		skip_dirs=()
		for skip; do
			if [[ -d ${ED%/}/${skip#/} ]]; then
				skip_dirs+=( "${ED%/}/${skip#/}" )
			else
				rm -f "${ED%/}/${skip#/}.ecompress" || die
			fi
		done

		if [[ ${skip_dirs[@]} ]]; then
			find "${skip_dirs[@]}" -name '*.ecompress' -delete || die
		fi

		exit 0
		;;
	--queue)
		shift

		find_args=()
		for path; do
			if [[ -e ${ED%/}/${path#/} ]]; then
				find_args+=( "${ED%/}/${path#/}" )
			fi
		done

		if [[ ${find_args[@]} ]]; then
			find_args+=( -type f )
			[[ -n ${PORTAGE_DOCOMPRESS_SIZE_LIMIT} ]] &&
				find_args+=( -size "+${PORTAGE_DOCOMPRESS_SIZE_LIMIT}c" )

			while IFS= read -d '' -r path; do
				>> "${path}.ecompress" || die
			done < <(find "${find_args[@]}" -print0 || die)
		fi

		exit 0
		;;
	--dequeue)
		[[ -n ${2} ]] && die "${0##*/}: --dequeue takes no additional arguments"
		break
		;;
	*)
		die "${0##*/}: unknown arguments '$*'"
		exit 1
		;;
	esac
	shift
done

# setup compression stuff
PORTAGE_COMPRESS=${PORTAGE_COMPRESS-bzip2}
[[ -z ${PORTAGE_COMPRESS} ]] && exit 0

if [[ ${PORTAGE_COMPRESS_FLAGS+set} != "set" ]] ; then
	case ${PORTAGE_COMPRESS} in
		bzip2|gzip)  PORTAGE_COMPRESS_FLAGS="-9";;
	esac
fi

guess_suffix() {
	if [[ ! -e ${T}/.ecompress.suffix ]] ; then
		set -e
		tmpdir="${T}"/.ecompress$$.${RANDOM}
		mkdir "${tmpdir}"
		cd "${tmpdir}"
		# we have to fill the file enough so that there is something
		# to compress as some programs will refuse to do compression
		# if it cannot actually compress the file
		echo {0..1000} > compressme
		${PORTAGE_COMPRESS} ${PORTAGE_COMPRESS_FLAGS} compressme > /dev/null
		# If PORTAGE_COMPRESS_FLAGS contains -k then we need to avoid
		# having our glob match the uncompressed file here.
		suffix=$(echo compressme.*)
		[[ -z $suffix || "$suffix" == "compressme.*" ]] && \
			suffix=$(echo compressme*)
		suffix=${suffix#compressme}
		cd /
		rm -rf "${tmpdir}"
		echo "${suffix}" > "${T}/.ecompress.suffix"
	fi
	cat "${T}/.ecompress.suffix"
}

# figure out the new suffix
suffix=$(guess_suffix)

compress_file() {
	mask_ext_re=""
	set -f
	for x in $PORTAGE_COMPRESS_EXCLUDE_SUFFIXES ; do
		mask_ext_re+="|$x"
	done
	set +f
	mask_ext_re="^(${mask_ext_re:1})\$"
	declare -a filtered_args=()
	i=0
	for x in "$@" ; do
		[[ ${x##*.} =~ $mask_ext_re ]] && continue
		[[ -s ${x} ]] || continue
		filtered_args[$i]=$x
		((i++))
	done
	[ $i -eq 0 ] && return 0
	set -- "${filtered_args[@]}"

	# If a compressed version of the file already exists, simply
	# delete it so that the compressor doesn't whine (bzip2 will
	# complain and skip, gzip will prompt for input)
	[[ -n ${suffix} ]] && echo -n "${@/%/${suffix}$'\001'}" | \
		tr '\001' '\000' | ${XARGS} -0 rm -f

	# forcibly break all hard links as some compressors whine about it
	while IFS= read -d '' -r x ; do
		cp -p "${x}" "${x}.ecompress.break" || die
		mv -f "${x}.ecompress.break" "${x}" || die
	done < <(find "${@}" -type f -links +1 -print0)

	# Finally, let's actually do some real work
	"${PORTAGE_COMPRESS}" ${PORTAGE_COMPRESS_FLAGS} "$@"
	ret=$?
	[[ $ret -ne 0 ]] && __helpers_die "${0##*/} failed"
	return ${ret}
}

fix_symlinks() {
	# Repeat until nothing changes, in order to handle multiple
	# levels of indirection (see bug #470916).
	local -i indirection=0
	while true ; do
	local something_changed=
	while read -r -d $'\0' brokenlink ; do
		[[ -e ${brokenlink} ]] && continue
		olddest=$(readlink "${brokenlink}")
		newdest=${olddest}${suffix}
		if [[ "${newdest}" == /* ]] ; then
			[[ -f "${D%/}${newdest}" ]] || continue
		else
			[[ -f "${dir}/${brokenlink%/*}/${newdest}" ]] || continue
		fi
		something_changed=${brokenlink}
		rm -f "${brokenlink}" &&
		ln -snf "${newdest}" "${brokenlink}${suffix}"
		((ret|=$?))
	done < <(find "${ED}" -type l -print0 || die)

	[[ -n ${something_changed} ]] || break
	(( indirection++ ))
	if (( indirection >= 100 )) ; then
		# Protect against possibility of a bug triggering an endless loop.
		eerror "ecompress: too many levels of indirection for" \
			"'${actual_dir#${ED%/}}/${something_changed#./}'"
		break
	fi
	done

	return ${ret}
}

ret=0
while IFS= read -d '' -r path; do
	file_path=${path%.ecompress}

	rm -f "${path}"
	compress_file "${file_path}"
	: $(( ret |= ${?} ))
done < <(find "${ED}" -name '*.ecompress' -print0 || die)

fix_symlinks
: $(( ret |= ${?} ))
[[ $ret -ne 0 ]] && __helpers_die "${0##*/} failed"

exit ${ret}
