#!/bin/bash
# Copyright 1999-2018 Gentoo Foundation
# Distributed under the terms of the GNU General Public License v2

source "${PORTAGE_BIN_PATH}"/isolated-functions.sh || exit 1

if [[ -z $1 ]] ; then
	__helpers_die "${0##*/}: at least one argument needed"
	exit 1
fi

if ! ___eapi_has_prefix_variables; then
	ED=${D} EPREFIX=
fi

while [[ $# -gt 0 ]] ; do
	case $1 in
	--ignore)
		shift
		for skip in "$@" ; do
			[[ -d ${ED%/}/${skip#/} || -f ${ED%/}/${skip#/} ]] \
				&& >> "${ED%/}/${skip#/}.ecompress.skip"
			rm -f "${ED%/}/${skip#/}".ecompress
		done
		exit 0
		;;
	--queue)
		shift
		ret=0
		for x in "${@#/}" ; do
			[[ -e ${ED%/}/${x} ]] || continue
			>> "${ED%/}/${x}.ecompress"
			((ret|=$?))
		done
		[[ $ret -ne 0 ]] && __helpers_die "${0##*/} failed"
		exit $ret
		;;
	--dequeue)
		[[ -n $2 ]] && __vecho "${0##*/}: --dequeue takes no additional arguments" 1>&2
		find "${ED}" -name '*.ecompress' -print0 \
			| sed -e 's:\.ecompress::g' -e "s:${ED%/}::g" \
			| ${XARGS} -0 ecompressdir
		find "${ED}" -name '*.ecompress.skip' -print0 | ${XARGS} -0 rm -f
		exit 0
		;;
	--*)
		__helpers_die "${0##*/}: unknown arguments '$*'"
		exit 1
		;;
	*)
		break
		;;
	esac
	shift
done

guess_suffix() {
	if [[ ! -e ${T}/.ecompress.suffix ]] ; then
		set -e
		tmpdir="${T}"/.ecompress$$.${RANDOM}
		mkdir "${tmpdir}"
		cd "${tmpdir}"
		# we have to fill the file enough so that there is something
		# to compress as some programs will refuse to do compression
		# if it cannot actually compress the file
		echo {0..1000} > compressme
		${PORTAGE_COMPRESS} ${PORTAGE_COMPRESS_FLAGS} compressme > /dev/null
		# If PORTAGE_COMPRESS_FLAGS contains -k then we need to avoid
		# having our glob match the uncompressed file here.
		suffix=$(echo compressme.*)
		[[ -z $suffix || "$suffix" == "compressme.*" ]] && \
			suffix=$(echo compressme*)
		suffix=${suffix#compressme}
		cd /
		rm -rf "${tmpdir}"
		echo "${suffix}" > "${T}/.ecompress.suffix"
	fi
	cat "${T}/.ecompress.suffix"
}

# figure out the new suffix
suffix=$(guess_suffix)

compress_file() {
	mask_ext_re=""
	set -f
	for x in $PORTAGE_COMPRESS_EXCLUDE_SUFFIXES ; do
		mask_ext_re+="|$x"
	done
	set +f
	mask_ext_re="^(${mask_ext_re:1})\$"
	declare -a filtered_args=()
	i=0
	for x in "$@" ; do
		[[ ${x##*.} =~ $mask_ext_re ]] && continue
		[[ -s ${x} ]] || continue
		filtered_args[$i]=$x
		((i++))
	done
	[ $i -eq 0 ] && exit 0
	set -- "${filtered_args[@]}"

	# If a compressed version of the file already exists, simply
	# delete it so that the compressor doesn't whine (bzip2 will
	# complain and skip, gzip will prompt for input)
	[[ -n ${suffix} ]] && echo -n "${@/%/${suffix}$'\001'}" | \
		tr '\001' '\000' | ${XARGS} -0 rm -f
	# Finally, let's actually do some real work
	"${PORTAGE_COMPRESS}" ${PORTAGE_COMPRESS_FLAGS} "$@"
	ret=$?
	[[ $ret -ne 0 ]] && __helpers_die "${0##*/} failed"
	return ${ret}
}

# funk_up_dir(action, suffix)
#	- action: compress
#	- suffix: the compression suffix to work with
# The directory we act on is implied in the ${dir} variable
funk_up_dir() {
	local act=$1 suffix=$2
	local size_limit=${PORTAGE_DOCOMPRESS_SIZE_LIMIT}

	[[ ${act} == "compress" ]] || die "${FUNCNAME}: invalid action: ${act}"

	local ret=0
	# first we act on all the files
	local args=(
		-type f
		! -iname "*${suffix}"
	)
	[[ -n ${size_limit} ]] && args+=( -size "+${size_limit}c" )
	local f
	while IFS= read -d '' -r f; do
		compress_file "${f}"
		((ret|=$?))
	done < <(find "${dir}" "${args[@]}" -print0)

	# Repeat until nothing changes, in order to handle multiple
	# levels of indirection (see bug #470916).
	local -i indirection=0
	while true ; do
	local something_changed=
	while read -r -d $'\0' brokenlink ; do
		[[ -e ${brokenlink} ]] && continue
		olddest=$(readlink "${brokenlink}")
		# Ignore temporarily broken symlinks due to
		# _relocate_skip_dirs (bug #399595), and handle
		# absolute symlinks to files that aren't merged
		# yet (bug #405327).
		if [[ ${olddest} == /* ]] ; then
			[ -e "${D%/}${olddest}" ] && continue
			skip_dir_dest=${T}/ecompress-skip/${olddest#${EPREFIX}}
		else
			skip_dir_dest=${T}/ecompress-skip/${actual_dir#${ED%/}}/${brokenlink%/*}/${olddest}
		fi
		[[ -e ${skip_dir_dest} ]] && continue
		newdest=${olddest}${suffix}
		if [[ "${newdest}" == /* ]] ; then
			[[ -f "${D%/}${newdest}" ]] || continue
		else
			[[ -f "${dir}/${brokenlink%/*}/${newdest}" ]] || continue
		fi
		something_changed=${brokenlink}
		rm -f "${brokenlink}"
		ln -snf "${newdest}" "${brokenlink}${suffix}"
		((ret|=$?))
	done < <(find "${dir}" -type l -print0)
	[[ -n ${something_changed} ]] || break
	(( indirection++ ))
	if (( indirection >= 100 )) ; then
		# Protect against possibility of a bug triggering an endless loop.
		eerror "ecompressdir: too many levels of indirection for" \
			"'${actual_dir#${ED%/}}/${something_changed#./}'"
		break
	fi
	done
	return ${ret}
}

# _relocate_skip_dirs(srctree, dsttree)
# Move all files and directories we want to skip running compression
# on from srctree to dsttree.
_relocate_skip_dirs() {
	local srctree="$1" dsttree="$2"

	[[ -d ${srctree} ]] || return 0

	find "${srctree}" -name '*.ecompress.skip' -print0 | \
	while read -r -d $'\0' src ; do
		src=${src%.ecompress.skip}
		dst="${dsttree}${src#${srctree}}"
		parent=${dst%/*}
		mkdir -p "${parent}"
		mv "${src}" "${dst}"
		mv "${src}.ecompress.skip" "${dst}.ecompress.skip"
	done
}
hide_skip_dirs()    { _relocate_skip_dirs "${ED}" "${T}"/ecompress-skip/ ; }
restore_skip_dirs() { _relocate_skip_dirs "${T}"/ecompress-skip/ "${ED}" ; }

ret=0

rm -rf "${T}"/ecompress-skip

# setup compression stuff
PORTAGE_COMPRESS=${PORTAGE_COMPRESS-bzip2}
[[ -z ${PORTAGE_COMPRESS} ]] && exit 0

if [[ ${PORTAGE_COMPRESS_FLAGS+set} != "set" ]] ; then
	case ${PORTAGE_COMPRESS} in
		bzip2|gzip)  PORTAGE_COMPRESS_FLAGS="-9";;
	esac
fi

for dir in "$@" ; do
	dir=${dir#/}
	dir="${ED%/}/${dir#/}"
	rm -f "${dir}.ecompress"
	if [[ -f ${dir} ]]; then
		compress_file "${dir}"
		continue
	elif [[ ! -d ${dir} ]] ; then
		continue
	fi
	cd "${dir}"
	actual_dir=${dir}
	dir=. # use relative path to avoid 'Argument list too long' errors

	# hide all the stuff we want to skip
	hide_skip_dirs "${dir}"

	# since we've been requested to compress the whole dir,
	# delete any individual queued requests
	find "${dir}" -type f -name '*.ecompress' -print0 | ${XARGS} -0 rm -f

	# forcibly break all hard links as some compressors whine about it
	find "${dir}" -type f -links +1 -exec env file="{}" sh -c \
		'cp -p "${file}" "${file}.ecompress.break" ; mv -f "${file}.ecompress.break" "${file}"' \;

	# now lets do our work
	if [[ -n ${suffix} ]] ; then
		__vecho "${0##*/}: ${PORTAGE_COMPRESS} ${PORTAGE_COMPRESS_FLAGS} /${actual_dir#${ED%/}}"
		funk_up_dir "compress" "${suffix}"
		: $(( ret |= $? ))
	fi

	# finally, restore the skipped stuff
	restore_skip_dirs
done

[[ $ret -ne 0 ]] && __helpers_die "${0##*/} failed"
exit ${ret}
